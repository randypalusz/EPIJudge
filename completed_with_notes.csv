Problem_Number,File_Name,Subject,Hints
4.1,parity.py,Primitive Types,Keep Track of number of 1's and increment when 1 is found. Return whether num of 1's is odd/even
5.1,dutch_national_flag.py,Arrays,cache value at idx and track 3 indices (lo=0 equal=0 hi=len(A)). while equal < hi: swap elements + increment indices based on status of A[equal] compared to cached value
5.6,buy_and_sell_stock.py,Arrays,Track minimum seen price and max profit (current_price - min_seen_price)
6.1,string_integer_interconversion.py,Strings,For int->string: do things from least to most significant digit then reverse the string
7.1,sorted_lists_merge.py,Linked Lists,Create new ListNode that is equal to a tail and dummy head. while L1 and L2 are valid: set the tail.next = the lower of the two and increment the appropriate one while incrementing tail. When done - append the remainng L1 or L2 to the tail and return head.next
8.3,is_valid_parenthesization.py,Stacks and Queues,Create map of {open: closed} characters and stack = []. For each char: if in map: add to queue. if in map vals: if map[stack.pop] != char: return false
9.1,is_tree_balanced.py,Binary Trees,Recursion. Create helper function that takes a tree node and returns tuple of (is_balanced; height). if node == null: return (True; 0). Get results for left and right nodes by recursing - returning result if arg[0] is False. check if is balanced (diff no greater than 1) and calculate new height (max of h1 and h2)) and return tuple of this
9.2,is_tree_symmetric.py,Binary Trees,Recursion. Create helper function that takes l and r tree node and returns bool. if one xor the other are null: return False. if both null: return True. get result of both l and r subnodes by recursing (result = helper(l.left r.right) and helper(l.right r.left) and l.data == r.data)
9.3,lowest_common_ancestor.py,Binary Trees,Recursion. Create helper that takes node - returns tuple (# target nodes found; lca node). Get results of node.left and node.right - returning result up stack if either has # target nodes found == 2. #_target_nodes_found = l_result nodes found + r_result nodes found + (target1 target2).count(node). return (#_target_nodes_found; node if #_target_nodes_found == 2 else None)
9.5,sum_root_to_leaf.py,Binary Trees,Recursion. Create helper that takes node and sum_to_node - returns the overall_sum of each path added to each other. If not node: return 0 (sum to add). Bit-shift sum_to_node left 1 (*2) and add node.data to it to store into sum_to_node. If a leaf (node.left and node.right == null) then return sum_to_node. return helper(node.left; current_sum) + helper(node.right; current_sum)
9.6,path_sum.py,Binary Trees,Recursion.Create helper that takes in node and remaining weight - returns whether the current root to leaf path sums to the weight passed. If not node: return False. Subtract the current data from the remaining weight. if is a leaf (not node.left and not node.right): return the status of weight (return remaining_weight == 0). Recurse by returning helper(node.left; remaining_weight) OR helper(node.right; remaining_weight) 
10.1,sorted_arrays_merge.py,Heaps,Pop the first value of each N sorted list. Get the min val amongst the N nums - append to the output. Grab the next number from the appropriate list to overwrite the previous num. If the appropriate list is empty: add some huge number in its place. Loop until all input lists are empty
12.1,is_string_permutable_to_palindrome.py,Hash Tables,Palindrome can be created if for each character seen - there exists at most one of those characters that is seen an odd number of times. Create dict of {char: #seen}. Check each value and see if there is an odd number there - if this result exceeds 1, return False.